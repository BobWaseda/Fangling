# 模拟重力排料算法说明

#### 陈博
#### mddboc@foxmail.com

## 〇、说明
&#8195;&#8195;本算法用到的主要函数在 Connection.h、Connection.cpp中，在Connection.h中对各个函数的功能和参数写了相应的注释。因此本文档的主要作用在于帮助阅读者了解算法的主要的思想（即写这些函数的具体作用是什么），便于维护与进一步优化。

## 一、算法思想
&#8195;&#8195;该算法的整体思想是模拟了真实世界中的自然重力堆积，即：向给定的二维密闭容器中扔圆，直到无法继续为止（给定的二维容器即得到的板料图像，圆即工件）。由于容器可以旋转（可以类比封闭的水杯中装有一定量的水），所以该算法中也需要对图像进行旋转，对不同的旋转角度应用重力算法，找到可以容纳圆最多的位置。


##二、算法中的重点与难点
###1、从哪个位置扔圆的问题
&#8195;&#8195;真实的物理世界中，我们可以想象这样的情景：一个人向空的瓶子中丢小石子，小石子就会自然下落。但是这其实建立在我们已知一个这样的起始位置，该起始位置可以放置一个小石子。那么在给定的板料的图像中，如何用较低的时间复杂度找到一个一定可以放置一个圆的初始位置呢？

###2、怎样模拟下落的问题
&#8195;&#8195;对于有着不规则外壁的容器来说，下落的过程分为几个步骤：垂直下落、沿着底边滚动、受上层物体挤压向某一方向移动。那么应该如何模拟比较复杂下落过程呢？

###3、旋转平移变换引发的坐标转换问题

###4、已经套料计算好的工件位置受上层工件挤压位置改变的问题
&#8195;&#8195;在以前的各种算法中，一旦经过套料计算得到了某一工件的位置后，该工件的位置便不再改变；但是在模拟重力的套料算法中，已经计算好位置的工件要受到后来工件的影响，有可能会改变位置。

###5、上层接口的问题
&#8195;&#8195;本算法的上层接口应该是切割好的各个连通域（包括每个连通域的一张图Array<int> status以及四个边界参数：first-true-h、last-true-h、first-true-w、last-true-w）。由于目前冲床套料系统的切割连通域算法并不完善，导致传递进来的图像与边界参数常常是不吻合的。这需要在套料算法正式进行计算以前，要进行四个边界参数的重新判断。这又进一步引起了时间复杂度的增加。

###6、如何尽可能减小时间复杂度的问题
&#8195;&#8195;通过以上的几个问题可以看出，本算法的算法逻辑比较复杂，完全照搬以前的算法套路会使得时间复杂度到了难以接受的地步，所以要尽可能采取各种办法减小时间复杂度。


##三、算法流程
###1、求取连通域边界参数
&#8195;&#8195;第二部分的问题5已经指出，连通域切割算法传递的结果不是十分可靠，所以要进行边界参数的再判断。具体函数是xxxxxx，方法和之前系统中用的寻找边界参数的方法是一样的，不再赘述。

###2、初始化参数
&#8195;&#8195;比较重要同时看起来比较“奇怪”的参数有以下几个：
####（1）has-calculated-angles:
&#8195;&#8195;旋转一周相当于旋转了360°，has-calculated-angles作为一个vector<int>初始化为360个0，意义是360种度数对应的情况都尚未进行计算。如果某一种情况已经计算过，那么将它对应的度数所在位置置为1，防止重复计算
####（2）candidate-angles：
&#8195;&#8195;算法的目标是选择排料个数最多的一种旋转角度进行坐标变换，但是事实上经常发生的情况是在不同的旋转角度下有着相同的工件数量（例如旋转24°、108°的排料个数均为24个），这时的做法是把这些旋转角度都加入到candidate-angles中，以这些排料相对较多的角度作为“种子”，继续细分步长以寻找下一个可能排料更多的角度（如果角度A比角度B的排料个数更多，那么有理由相信角度A的周围存在排料数更多的角度的__概率__会更大）。
####（3）next-step：
&#8195;&#8195;第二部分的问题6已经指出，我们要尽可能地减小时间复杂度，那么遍历360个角度对应的360种情况显然不是一种时间复杂度低的做法。为了减小时间复杂度，这里采取的办法是__“变步长方法”__。首先将360°分成5份（即步长为72°），计算0°、72°、144°、216°和288°时工件的数量，把排料较多的情况对应的角度放进candidate-angles中；然后以candidate-angles中的角度为__“搜索种子角度”__，步长设为24°继续进行计算（例如上次排料较多的情况是72°和216°，那么这次要计算的角度是48°、96°、192°和240°）；……以此类推。算法中设计的步长是72、24、8、4、2、1（单位：°），根据实际情况选择终止计算步长，一般选择终止计算步长为24°或8°。

###3、设置ROI（Region of Interest）
&#8195;&#8195;每次传递进来的图片中只有一部分是我们需要进行处理的，即四个边界参数包围的部分。为了模拟不同角度下的情况，我们还需要对图像进行旋转。旋转的中心是有效区域的中心。为了防止旋转过程中出现有效区域转出图像范围内，采用的方法是计算有效区域的对角线长度，对角线长度加上4作为有效区域的尺寸，这样的有效区域是一个正方形，这样就不会出现有效区域转出图像范围的问题。

###4、算法主体的递归函数 RotationCalculationHelper函数
&#8195;&#8195;递归函数的作用是根据传递进来的几个参数：起始角度、终止角度和步长，计算几种角度下的排料情况。这一递归函数又包括以下几个步骤：
####（1）图像旋转：根据当前的角度，先将Array<int>转为cv::Mat，然后调用OpenCV的warpAffine函数进行旋转，再将cv::Mat转成Array<int>进行处理。
####（2）寻找旋转后图像的边界参数：同样是调用FindFWAndLWAndFHAndLH函数。
####（3）粗排料RoughlyNestingForGravitySimulation函数：思想用一张大的套料模板覆盖在图像上方进行移动，移动的次数由move_counts参数决定。
####（4）精排料AccuratelyNestingForGravitySimulation函数：核心环节，在第四部分详细说明
####（5）后续处理：如果当前角度的排料个数比之前的角度都多，那么保存这次的角度以及排料结果；如果和之前排料个数的最大值相等，那么把这次的角度也加入到candidate-angles中，作为下一次调用时生成其他角度的“种子角度”；如果比之前排料个数的最大值小，那么不做任何处理。
###5、坐标转换与排料结果涂色 InverseCoordinatesOfCirclesConversion函数
&#8195;&#8195;递归函数得到的工件坐标是相对于提取ROI并且旋转后的图像原点而言，最终要得到的坐标是相对于刚开始传进来的连通域图像原点，所以要进行坐标变换。变换的最终公式见InverseCoordinatesOfCirclesConversion函数。坐标转换成功后，为了显示图像，要在原来传进来的连通域图像中涂色。坐标变换公式的来历见第五部分。

##四、精排料函数AccuratelyNestingForGravitySimulation的步骤
&#8195;&#8195;粗排料得到的结果是std::vector<std::vector<image::Point<int> > > origin-result，origin-result中的每一个vector保存的是当前层的圆的粗排结果（每一个vector中的所有圆的列坐标是相同的）。精排料函数的处理方式是把每一列作为一个整体进行下落（这样解决了第二部分的问题1）及其他各种处理。对于每一列的圆来说需要进行下列步骤：
####（1）调整之前一层圆的位置 AdjustLastColumnForGravitySimulation函数（第一列的圆不需要进行这个步骤）：
&#8195;&#8195;后来的圆会影响之前的圆的位置，为了简化问题，算法中处理为每一层的圆只受它们后一层的圆影响，而不受再后来层的圆的影响。对于之前一层的圆，首先要得到它们的移动方向：如果它的位置在后一层的所有圆的左侧，那么它从当前列的最左端行的边界开始找合适的位置，终止条件就是它的当前行；如果它的位置在后一层所有圆的右侧，同样的道理从右开始搜索合适的位置；否则，不做任何处理。
####（2）清除当前层的圆的图像 RePaintSingleColumnForGravitySimulation函数
&#8195;&#8195;首先要模拟圆的下落，但是圆的下落距离并不总是大于自身直径，因此首先要将当前层的圆的图像清除。由于本算法中一直没有引入ToleranceAcceptance系统，因此清除一个圆不会影响图像的其他部分。具体方法就是根据粗排料得到的坐标，把当前圆覆盖的部分全部置为0。
####（3）当前层的圆下落 DropDownSingleColumnForGravitySimulation函数
&#8195;&#8195;这一步只进行圆的列坐标变化，而不改变圆的行坐标，模拟的是垂直下落的过程。具体的方法是找到当前行满足条件的最大列，结果记录在intermediate_result中。
####（4）调整下落得到的圆的坐标 AdjustIntermediateResult函数
&#8195;&#8195;圆下落后要进行的步骤是向周围位置更低的地方“滚”，位置更低的圆有优先“滚”的权利。因此这一步要进行排序，位置更低的圆（即列号更大的圆）排序在前位。
####（5）重新调整圆的位置 CurrentColumnCirclesRearrange函数
&#8195;&#8195;第（3）步只改变了圆的列坐标，这一步既改变圆的列坐标，又改变圆的行坐标。做法是从可能满足要求的最大列（end_drop_down_column）开始，以当前行位置为中心，左右“晃动”找合适的最低位置（因为如果底面是平的，那么它将保持当前位置不动；只有底面确实向下倾斜时，圆才有向某一侧滚的动力从而离开当前行）。
####（6）调整下落得到的圆的坐标 AdjustIntermediateResult函数
####（7）重新调整圆的位置 CurrentColumnCirclesRearrange函数
&#8195;&#8195;第（6）、（7）步的做法和第（4）、（5）步完全相同，要重复进行这一过程的原因是为了避免一种情况的发生，如图所示。
####（8）再重新调整圆的位置 AdjustSingleColumnFinalResult函数
&#8195;&#8195;把上一步得到的圆的坐标按照从外到里的顺序排列（“外”指的是靠近某一行边界的一侧）。这样做的目的是方便进行第（1）步的调整，因为当前层的圆受到后层圆的挤压时，处于外侧的圆会首先朝某一方向移动，然后才是内侧的圆移动。
