1、把模板中心与有效区域中心对齐，进行粗略的第一次排料

2、把第一次排料的结果用  vector<vector<int>> 保存，每个vector<int>里面的圆的row是一样的

3、每一列作为一个整体集体下落，写一个for循环，每次整体垂直下落一个像素，对于每个卡住不能再下落的圆，记录它最后满足条件的位置（用一个vector<Point<Point<int>, int>>）以及它在这一列圆中的序列号
（从左往右依次是0——n），直到所有的圆都真的无法垂直下落了

4、把刚才的vector<Point<Point<int>, int>>的元素逆序取出来，按照位置最低优先，根据它的序列号决定它是从左搜还是从右搜，
搜索的高度终点是vector<Point<Point<int>, int>>保留的它之前的位置，水平终点是已经确定位置了的左右圆的参考点，确定好位置后涂色
先完成这步再说。。。

5、对于以后的每列，重复3、4步，直到把 vector<vector<int>>取干净

6、在上方进行逐列扫描，寻找剩余空间内能放的个数

7、每一行决定之后都用双链表记录相邻的圆，等下一行下落过程完毕后，前一行的圆分为被新的一行直接挤压的圆和被同行挤压的圆，先移动被同行挤压的圆到合适位置，
然后移动被新的一行挤压的圆，最后移动新一行的圆

8、关于旋转的思路：
把有效区域转成mat，调用opencv的旋转函数，再把mat转为status，原始坐标变换一下，在新的图上重新下落

坐标变换：（横坐标为col，纵坐标为row）

原始图中，原点是最左下角的点，各圆形参考点坐标  (x0, y0)     

1° 原始图 ——> 不旋转只切割核心区域的图中，原点是切割后的核心区域中最左下角的点，圆形参考点坐标 (x1, y1)
     设切割后的核心区域共 Rows 行， Cols列
         x1 = x0 - ( (first_true_w_ + last_true_w_)/2 - Cols/2 );
         y1 = y0 - ( (first_true_h_ + last_true_h_)/2 - Rows/2 );

2° 不旋转只切割核心区域的图中，原点是切割后的核心区域中的中心点，圆形参考点坐标 (x2, y2)
         x2 = x1 - Cols/2 = x0 - (first_true_w_ + last_true_w_)/2;
         y2 = y1 - Rows/2 = y0 - (first_true_h_ + last_true_h_)/2;
   
   各圆形圆心坐标 (x3,y3)
         x3 = x2 + space.width_/2 = x0 - (first_true_w_ + last_true_w_)/2 + space.width_/2;
         y3 = y2 + space.width_/2 = y0 - (first_true_h_ + last_true_h_)/2 + space.width_/2;
         
3°切割后的核心区域 旋转角度为 θ，旋转中心是 核心区域中心点， 原点是核心区域中心点， 旋转后 各圆形 圆心坐标(x4,y4)
         x4 =  x3 * cosθ + y3 * sinθ
         y4 = -x3 * sinθ + y3 * cosθ

4°各圆形 参考点坐标 (x5, y5)
         x5 = x4 - space.width_/2 
            = x3 * cosθ + y3 * sinθ - space.width_/2
            = ( x0 - (first_true_w_ + last_true_w_)/2 + space.width_/2 ) * cosθ 
            + ( y0 - (first_true_h_ + last_true_h_)/2 + space.width_/2 ) * sinθ 
            - space.width_/2;
            
         y5 = y4 - space.width_/2 
            = -x3 * sinθ + y3 * cosθ - space.width_/2
            = ( -x0 + (first_true_w_ + last_true_w_)/2 - space.width_/2 ) * sinθ 
            + ( y0 - (first_true_h_ + last_true_h_)/2 + space.width_/2 ) * cosθ
            - space.width_/2;
            
    接下来对所有的 (x5,y5) 按照x5排序(x5大的排在前面），
然后把所有的进行分层：
    首先取第一个圆的col坐标，循环终止条件是 当前圆col坐标小于第一个圆的col坐标+圆的直径，如果当前圆的row坐标小于第一个圆的row坐标 - 圆的直径 或
当前圆的row坐标大于第一个圆的row坐标 + 圆的直径，把当前圆加入改层，用一个vector<pair>存该层圆的row范围（在已有的该层圆的[-diameter,diameter]范围
内为不符合）
这样所有圆分好层后，用之前的套路下落移动

private:
    vector<int> has_calculated_angles_;
    max_circle_nums_ ;
    set<int, greater<int> > candidate_angles_;
    int chosen_angle_;
    unordered_map<int, int> next_step_;


void Calculation()
{
    has_calculated_angles_.reserve(360);
    has_calculated_angles_.assign(360, 0);
    max_circle_nums_ = 0;
    set<int, greater<int> >().swap(candidate_angles_);
    next_step_[72] = 24;
    next_step_[24] = 8;
    next_step_[8] = 4;
    next_step_[4] = 2;
    next_step_[2] = 1;

    CalculationHelper(0, 360, 72);
}


void CalculationHelper(int start_angle, int end_angle, int step)
{
    for ( int i = start_angle; i <= end_angle; i += step )
    {
        if ( has_calculated_angles_[ (i + 360) % 360] == 0 )
            has_calculated_angles_[ (i + 360) % 360] = 1;
        else 
            continue;
            
        SingleCalculation(temp_result, circle_nums);
        if ( circle_nums > max_circle_nums_ )
        {
            max_circle_nums_ = circle_nums; 
            result_ = temp_result;
            set<int, greater<int> >().swap(candidate_angles_);
            candidate_angles_.push_back(i);
        }
        else if ( circle_nums > max_circle_nums_ )
        {
            candidate_angles_.push_back(i);
        }
    }
    
    if ( step == 1 || (int)candidate_angles_.size() >= 45)
    {
        chosen_angle_ = *( candidate_angles_.begin() );
        return;
    }
    else
    {
        int new_step = next_step_[step];
        int new_start_angle = *( candidate_angles_.begin() ) - new_step;
        int new_end_angle = *( candidate_angles_.end() - 1) + new_step;

        CalculationHelper(new_start_angle, new_end_angle, new_step);
    }
}






