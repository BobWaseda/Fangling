1、把模板中心与有效区域中心对齐，进行粗略的第一次排料

2、把第一次排料的结果用  vector<vector<int>> 保存，每个vector<int>里面的圆的row是一样的

3、每一列作为一个整体集体下落，写一个for循环，每次整体垂直下落一个像素，对于每个卡住不能再下落的圆，记录它最后满足条件的位置（用一个vector<Point<Point<int>, int>>）以及它在这一列圆中的序列号
（从左往右依次是0——n），直到所有的圆都真的无法垂直下落了

4、把刚才的vector<Point<Point<int>, int>>的元素逆序取出来，按照位置最低优先，根据它的序列号决定它是从左搜还是从右搜，
搜索的高度终点是vector<Point<Point<int>, int>>保留的它之前的位置，水平终点是已经确定位置了的左右圆的参考点，确定好位置后涂色
先完成这步再说。。。

5、对于以后的每列，重复3、4步，直到把 vector<vector<int>>取干净

6、在上方进行逐列扫描，寻找剩余空间内能放的个数

7、每一行决定之后都用双链表记录相邻的圆，等下一行下落过程完毕后，前一行的圆分为被新的一行直接挤压的圆和被同行挤压的圆，先移动被同行挤压的圆到合适位置，
然后移动被新的一行挤压的圆，最后移动新一行的圆
